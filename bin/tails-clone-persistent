#!/usr/bin/perl -T
my $program = 'tails-clone-persistent';
my $version = '0.1';

#######################################################################
#
# tails-clone-persistent
#
# We call /usr/sbin/tcp-helper to do the dirty work. It is setuid
# root (in order to create filesystems and set permissions) but has
# no user interaction or intelligence. That's all safely in here.
#
#######################################################################


use strict;
use warnings;

use Expect;
use Gtk2 '-init';

#use Linux::ACL;		# would be nice but it's not packaged

# Secure our path
$ENV{'PATH'} = '/bin:/usr/bin:/sbin:/usr/sbin';

my $expect_timeout = 300; # Is this enough? Data flushing can be slooow
my $persist_location = '/live/persistence/TailsData_unlocked';
my $helper_utility = '/usr/sbin/tcp-helper';

# for tails v2.x
my $tails_installer = '/usr/lib/tails_installer/tails-installer';

# for tails v1.x
my $v1_tails_installer = '/usr/bin/liveusb-creator';


#############################
# Process command line args #
#############################

my %CMD_OPTIONS;

sub parse_options {
  while($ARGV[0] and $ARGV[0]=~/^--/) {
	my $option = shift(@ARGV);
	my $value = 1;
	$option =~ s/^--//;
	if($option =~ /=/) {
		($option, $value) = split('=', $option);
	}
	$CMD_OPTIONS{$option} = $value;
  }
} 

sub option_help {
	print qq[This is ${program} v${version}
	 
It takes the following options:

--help     This help
--debug    Debugging information
--skel=DIR Copy the contents of DIR instead
--pull     Clone another persistent partition to this one (needs root)

];
}


################################
# Graphical interface routines #
################################


# Need global access to window, hboxes, buttons to toggle visibility
my ($graphic_window, 
	$working_hbox, 
	$pass_hbox, 
	$pass_confirm_hbox, 
	$chooser_hbox, 
	$reuse_hbox, 
	$button_hbox, 
	$quit_button, 
	$continue_button);

# Need global access to particular widgets to read and write contents
my ($working_label, $pass_entry, $pass_confirm_entry, $chooser);

# Event success flag
my ($event_outcome);

sub graphic_window_init() {

	$graphic_window = Gtk2::Window->new();
	$graphic_window->set_title('Persistent Volume Cloner');
	$graphic_window->signal_connect('delete-event' => sub {exit(-1);});

	my $vbox = Gtk2::VBox->new;

	# First a label - we'll fill this with relevant information as we go.

	$working_hbox = Gtk2::HBox->new;
	$working_label = Gtk2::Label->new('Working...');

	$working_hbox->pack_start($working_label, 0,0,5);
	$vbox->pack_start($working_hbox, 0,0,5);

	# Passphrase entry

	$pass_hbox = Gtk2::HBox->new;
	
	my $pass_label = Gtk2::Label->new('Passphrase:');

	$pass_entry = Gtk2::Entry->new;
	$pass_entry->set_visibility(0);
	$pass_entry->set_invisible_char('*');
	
	$pass_hbox->pack_start($pass_label, 0,0,5);
	$pass_hbox->pack_start($pass_entry, 1,1,5);
	$vbox->pack_start($pass_hbox, 0,0,0);

	# And confirm...

	$pass_confirm_hbox = Gtk2::HBox->new;

	my $pass_confirm_label = Gtk2::Label->new('Confirm:');

	$pass_confirm_entry = Gtk2::Entry->new;
	$pass_confirm_entry->set_visibility(0);
	$pass_confirm_entry->set_invisible_char('*');

	$pass_confirm_hbox->pack_start($pass_confirm_label, 0,0,5);
	$pass_confirm_hbox->pack_start($pass_confirm_entry, 1,1,5);
	$vbox->pack_start($pass_confirm_hbox, 0,0,5);

	# Chooser
	# We create this empty now, and add entries to it later 
	# Note the perl GTK2 interface doesn't implement ComboBoxText yet.

	$chooser_hbox = Gtk2::HBox->new;
	$chooser = Gtk2::ComboBox->new_text;

	$chooser_hbox->pack_start($chooser, 1,1,5);
	$vbox->pack_start($chooser_hbox, 0,0,5);

	# Reuse or overwrite

	$reuse_hbox = Gtk2::HBox->new;

	my $trash_button = Gtk2::Button->new_with_mnemonic('_Delete and recreate');
	$trash_button->signal_connect('clicked'=> sub{$event_outcome=0; Gtk2->main_quit});

	my $reuse_button = Gtk2::Button->new_with_mnemonic('_Reuse existing');
	$reuse_button->signal_connect('clicked'=> sub{$event_outcome=1; Gtk2->main_quit});

	$reuse_hbox->pack_start($trash_button, 0,0,5);
	$reuse_hbox->pack_end($reuse_button, 0,0,5);
	$vbox->pack_start($reuse_hbox, 0,0,5);

	# Quit and Continue buttons. We'll reuse these as much as we can.

	$button_hbox = Gtk2::HBox->new;
	
	$quit_button = Gtk2::Button->new_with_mnemonic('_Quit');
	$quit_button->signal_connect('clicked'=> sub{$event_outcome=0; Gtk2->main_quit});

	$continue_button = Gtk2::Button->new_with_mnemonic('_Continue');
	$continue_button->signal_connect('clicked'=> sub{$event_outcome=1; Gtk2->main_quit});

	$button_hbox->pack_end($continue_button, 0,0,5);
	$button_hbox->pack_end($quit_button, 0,0,5);
	$vbox->pack_end($button_hbox, 0,0,5);

	# add vbox to window and show everything in the vbox by default
	# we'll hide specific hboxes elsewhere
	
	$graphic_window->add($vbox);
	$vbox->show_all;

}


sub secure_input() {
	my $prompt = shift;
	my $input='';
	$working_label->set_text($prompt);
	$pass_entry->set_text('');
	
	$working_hbox->show;
	$pass_hbox->show;
	$pass_confirm_hbox->hide;
	$chooser_hbox->hide;
	$reuse_hbox->hide;
	$button_hbox->show_all;
	
	$event_outcome=0;
	$graphic_window->show;
	Gtk2->main;
	
	if($event_outcome){
		$input=$pass_entry->get_text();
		$input =~ s/[\n\r\f\t]//g;
	}

	$pass_entry->set_text('');
	return $input;
}


sub ask_passphrase() {
	$working_label->set_text(
	q[A passphrase will be used to encrypt your new persistent partition.

The passphrase should contain at least 16 characters, and at least one 
non-alphanumeric character, such as punctuation.
]);
	my ($passphrase, $confirm, $success);
	
	do {
		$pass_entry->set_text('');
		$pass_confirm_entry->set_text('');
		
		$working_hbox->show;
		$pass_hbox->show;
		$pass_confirm_hbox->show;
		$chooser_hbox->hide;
		$reuse_hbox->hide;
		$button_hbox->show_all;

		$graphic_window->show;
		Gtk2->main;
		
		return '' unless $event_outcome;
		
		$passphrase = $pass_entry->get_text();
		$confirm = $pass_confirm_entry->get_text();
		$passphrase =~ s/[\n\r\f\t]//g;
		$confirm =~ s/[\n\r\f\t]//g;

		if(length($passphrase) < 16 or
			$passphrase !~ /[^[:alnum:]]/) {
			$working_label->set_text(
			q[PASSPHRASE IS NOT STRONG ENOUGH - PLEASE TRY AGAIN
			
The passphrase should contain at least 16 characters, and at least one 
non-alphanumeric character, such as punctuation.
]) ;
		} elsif($passphrase ne $confirm) {
			$working_label->set_text(
			q[CONFIRMATION DOES NOT MATCH - PLEASE TRY AGAIN

The passphrase should contain at least 16 characters, and at least one 
non-alphanumeric character, such as punctuation.
]);
		} else {
			$success=1;
		}
	} until($success);
	
	$pass_entry->set_text('');
	$pass_confirm_entry->set_text('');
	return $passphrase;
}


sub make_submenu() {
	my $prompt = shift;
	$working_label->set_text($prompt);
	
	foreach my $i (@_) {
		$chooser->append_text($i);
	}
	$chooser->set_active(0);
	
	$working_hbox->show;
	$pass_hbox->hide;
	$pass_confirm_hbox->hide;
	$chooser_hbox->show;
	$reuse_hbox->hide;
	$button_hbox->show_all;
	
	$event_outcome=0;
	$graphic_window->show;
	Gtk2->main;
	
	return '' unless $event_outcome;
	
	my $index=$chooser->get_active;
	
	return $_[$index];
	
}

sub make_confirm() {
	my $prompt = shift;
	my $input='';
	$working_label->set_text($prompt);
	
	$working_hbox->show;
	$pass_hbox->hide;
	$pass_confirm_hbox->hide;
	$chooser_hbox->hide;
	$reuse_hbox->hide;
	$button_hbox->show_all;
	
	$event_outcome=0;
	$graphic_window->show;
	Gtk2->main;
	
	return $event_outcome;
}

sub make_reuse() {
	my $prompt = shift;
	my $input='';
	$working_label->set_text($prompt);
	
	$working_hbox->show;
	$pass_hbox->hide;
	$pass_confirm_hbox->hide;
	$chooser_hbox->hide;
	$reuse_hbox->show_all;
	$button_hbox->hide;
	
	$event_outcome=0;
	$graphic_window->show;
	Gtk2->main;
	
	return $event_outcome;
}

sub make_success() {
	my $prompt = shift;
	my $input='';
	$working_label->set_text($prompt);
	
	$working_hbox->show;
	$pass_hbox->hide;
	$pass_confirm_hbox->hide;
	$chooser_hbox->hide;
	$reuse_hbox->hide;
	$button_hbox->show_all;
	$continue_button->hide;
	
	$event_outcome=0;
	$graphic_window->show;
	Gtk2->main;
	
	return $event_outcome;
}

sub make_failure() {
	# failure is so near to success ;-)
	&make_success(shift);
	die;
}

sub make_progress() {
	my $prompt = shift;
	my $input='';
	$working_label->set_text($prompt);
	
	$working_hbox->show;
	$pass_hbox->hide;
	$pass_confirm_hbox->hide;
	$chooser_hbox->hide;
	$reuse_hbox->hide;
	$button_hbox->hide;
	
	$graphic_window->show;
	
	if($CMD_OPTIONS{'debug'}) {
		# wait for the user to press continue
		$button_hbox->show_all;
		$quit_button->hide;
		Gtk2->main;
	} else {
		# return success immediately so we can keep doing stuff
		return 1;
	}
}


#################################


sub get_tails_partition {
	my $tails_partition;
	my $pipe;
	
	open($pipe, '/bin/mount|') 
		or &make_failure("Failed to read mount points. Aborting.");
	while(<$pipe>) {
		print $_ if $CMD_OPTIONS{'debug'};
		if(m!^([/[:alnum:]._-]+) on /lib/live/mount/medium type vfat!) {
			$tails_partition = $1;
			last;
		}
	}
	close $pipe;
	return $tails_partition;
}

sub choose_block_device {
	my $prompt = shift;
	my $except = shift;
	my @block_devices;
	my $pipe;

	open($pipe, '/sbin/blkid |');
	while(<$pipe>) {
		print $_ if $CMD_OPTIONS{'debug'};
		if(m!^([/[:alnum:]._-]+): LABEL="Tails" UUID="[a-fA-F0-9-]+" TYPE="vfat"!) {
			my $device = $1;
			if($device ne $except) {
				chop $device;
				push(@block_devices, $device);
			}
		}
	}
	close $pipe;
	
	if(@block_devices) {
		# TODO: give user better info in menu, e.g. make and model?
		return &make_submenu($prompt, @block_devices);
	} elsif(&make_confirm(
		q[No other tails drives found. Do you want to create a new one?])
	) {
		&make_confirm(qq[Insert a new USB drive (minimum 4GB)]);
		system($tails_installer, '-u', '-n', '--clone', '-P', '-m', '-x');
		return &choose_block_device($prompt, $except);
	}
}

sub mount_device {
	my $block_device = shift;
	my $mount_point;
	my $pipe;
	
	print qq[Mounting crypted partition...\n] if $CMD_OPTIONS{'debug'};
	open($pipe, "/usr/bin/udisksctl mount --block-device ${block_device}|")
		or &make_failure("Could not mount disk ${block_device}. Aborting.");
	while(<$pipe>) {
		print $_ if $CMD_OPTIONS{'debug'};
		if(m!^Mounted \S+ at ([/[:alnum:]._-]+)!) {
			$mount_point = $1;
			last;
		}
	}
	close $pipe;
	return $mount_point;
}


##################################


sub clone_to_tails() {	
	my $source_location_unsafe = shift;
	my $tails_partition = &get_tails_partition();
	my ($partition_mode, $passphrase);
	
	# sanitise input
	&make_failure("Unsafe characters in source path. Aborting.") unless 
		$source_location_unsafe =~ m!^([[:alnum:][:digit:]/_.,+=-]*)$!;
	my $source_location = $1;
	
	&make_failure("Could not determine running Tails partition. Aborting.") unless $tails_partition;
	print "Tails volume found on $tails_partition\n" if $CMD_OPTIONS{'debug'};

	my $block_device = &choose_block_device('SELECT TAILS DISK TO COPY TO', $tails_partition);
	return unless $block_device;
	
	# if a persistent partition already exists on the target drive
	if(-b "${block_device}2") {
		return unless &make_confirm("Update the existing persistent data on ${block_device}?");

		my $reuse = &make_reuse(
q[If you know the passphrase of the target partition, you can reuse it. 
This is faster, and could (slightly) extend the life of your disk.

Otherwise, you should delete it and make one with a new passphrase.
]);

		if($reuse){
			$partition_mode='existing';
			$passphrase = &secure_input('Please unlock the target disk');
		}
	} 
	
	# if no passphrase given (incl. if there was no existing partition)
	unless($passphrase) {
		$partition_mode='new';
		$passphrase = &ask_passphrase;
		return unless $passphrase;
	}
	
	# Now call expect to handle the setuid helper
	&make_progress('Copying data...');
	
	$ENV{'TCP_HELPER_DEBUG'}='1' if $CMD_OPTIONS{'debug'};
	my $exp = Expect->spawn($helper_utility, $source_location, $block_device, $partition_mode);
	&make_failure("Could not run ${helper_utility}. Aborting.") unless $exp;

	if($CMD_OPTIONS{'debug'}) {
		$exp->exp_internal(1);
	} else {
		$exp->log_stdout(0);
	};
	
	$exp->expect($expect_timeout, 
	
		# Fatal errors
		[
		"Cannot exec", sub{
			&make_failure("Could not run ${helper_utility}. Aborting.");
		}], [
		"Usage: ${helper_utility}", sub{
			&make_failure("Bad syntax when calling ${helper_utility}. Aborting.");
		}], [
		/TCPH-ERROR (.*)$/, sub{
			&make_failure("$1. Aborting.");
		}],	
		
		# old, specific error handlers
#		[
#		"Could not mount crypted volume", sub{
#			&make_failure("Could not mount crypted partition. Aborting.");
#		}], [
#		"Could not detect end of tails primary partition", sub{
#			&make_failure("Could not detect end of tails primary partition. Aborting.");
#		}], [
#		"Unsafe characters detected in filename", sub{
#			&make_failure("Unsafe characters in source path. Aborting.");
#		}], [
#		"Could not set permissions on", sub{
#			&make_failure("Could not set permissions on target drive. Aborting.");
#		}], [
#		"Could not set ACLs on", sub{
#			&make_failure("Could not set ACLs on target drive. Aborting.");
#		}], [
#		"Could not unlock crypted volume", sub{
#			&make_failure("Could not unlock crypted volume. Bad password? Aborting.");
#		}], [
#		"Could not unlock new crypted volume", sub{
#			&make_failure("Could not unlock crypted volume. This should never happen. Aborting.");
#		}], [
#		"Could not create new partition", sub{
#			&make_failure("Could not create new partition. Aborting.");
#		}], [
#		"Could not rename new partition", sub{
#			&make_failure("Could not rename new partition label. Aborting.");
#		}], [
#		"Could not initialise crypted volume", sub{
#			&make_failure("Could not initialise crypted volume. Aborting.");
#		}], [
#		"Error syncing files", sub{
#			&make_failure("Error syncing files. Aborting.");
#		}], [
#		"Could not create filesystem on new crypted volume", sub{
#			&make_failure("Could not create filesystem on new crypted volume. Aborting.");
#		}], [
#		"Could not randomise free space on new crypted volume", sub{
#			&make_failure("Could not randomise free space on new crypted volume. Aborting.");
#		}], [
#		"Could not delete old persistent partition", sub{
#			&make_failure("Could not delete old persistent partition. Aborting.");
#		}], [
#		"Failed to lock partition", sub{
#			&make_failure("Failed to lock partition. You may need to unmount manually. Aborting gracelessly!");
#		}],
		
		# Progress indicators
		[
		/TCPH (.*)$/, sub{
			&make_progress("$1");
		}],	
		
		# old, specific progress handlers
#		[
#		"Mounting crypted partition", sub{
#			&make_progress('Mounting crypted partition...');
#		}], [
#		"Creating new partition", sub{
#			&make_progress('Creating new crypted partition...');
#		}], [
#		"Using existing partition", sub{
#			&make_progress('Using existing crypted partition...');
#		}], [
#		"waiting for buffers to flush", sub{
#			&make_progress('Flushing data to disk...');
#		}], [
#		"plausible deniability", sub{
#			&make_progress('Randomising free space for plausible deniability (this may take some time)...');
#		}], [
#		"Copy complete", sub{
#			&make_progress('Copy complete');
#		}],	
		
		# Request and response
		[
		"Type uppercase yes", sub{
			my $self=shift;
			# I suspect a race condition here, as this often fails with
			# a permissions error within expect, but never fails when
			# run by hand. Sleep for a while to let data flushing 
			# happen in the background.
			sleep(1);
			$self->send("YES\n");
			exp_continue;
		}], [
		"(Enter|Verify) passphrase", sub{
			my $self=shift;
			# allow subprocess to flush input buffer on slow H/W
			sleep(1);
			$self->send("${passphrase}\n");
			exp_continue;
		}]
	);
	
	&make_success('Copy complete');
}


sub clone_from_tails {	
	my $tails_partition = &get_tails_partition();
	&make_failure("Could not determine running Tails partition. Aborting.") unless $tails_partition;
	print "Tails volume found on $tails_partition\n" if $CMD_OPTIONS{'debug'};

	my $block_device = &choose_block_device('SELECT TAILS DISK TO COPY FROM', $tails_partition);
	return unless $block_device;

	return unless &make_confirm("Overwrite your running Tails persistent volume using ${block_device}?");

	# don't use setuid helper for pull
	# a) safer to require sudo to overwrite the running configuration
	# b) we only need 'pull' in rare edge cases, if ever
	
	my $partition = "${block_device}2";
	system('/sbin/cryptsetup', 'luksOpen', $partition, 'TailsData_source');
	#will prompt for a password
	
	my $mount_point = &mount_device('/dev/mapper/TailsData_source');
	&make_failure("Could not mount disk") unless $mount_point;
	print "Crypted volume mounted on $mount_point\n" if $CMD_OPTIONS{'debug'};

	print qq[Copying files...];
	system('/usr/bin/rsync', '-a', '--delete', "--exclude=gnupg/random_seed", 
		"${mount_point}/", $persist_location);
	print qq[done\n];

	system('/usr/bin/udisksctl', 'unmount', '--block-device', '/dev/mapper/TailsData_source');
	do {
		&make_progress('Flushing data to disk...');
	} until system('/sbin/cryptsetup', 'luksClose', 'TailsData_source')==0;
	&make_progress('Copy complete');
}


#####################################


sub main {
	&parse_options;
	&graphic_window_init;
	
	if(-x $v1_tails_installer) {
		# handle changing locations/names of the tails installer
		$tails_installer = $v1_tails_installer
	}
	
	if($CMD_OPTIONS{'help'}) {
		&option_help;
	} elsif($CMD_OPTIONS{'pull'}) {
		if($> != 0) {
			&make_failure("Only root can overwrite running config; try again using sudo.");
		}
		&clone_from_tails;
	} elsif($CMD_OPTIONS{'skel'}) {
		&clone_to_tails($CMD_OPTIONS{'skel'});
	} else {
		&clone_to_tails($persist_location);
	}
}

&main;
